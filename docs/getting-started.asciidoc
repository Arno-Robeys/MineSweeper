// ROOT
:tip-caption: üí°
:note-caption: ‚ÑπÔ∏è
:important-caption: ‚ö†Ô∏è
:task-caption: üî®
:source-highlighter: pygments
:toc: left
:toclevels: 3
:experimental:
:nofooter:

= Getting Started

[IMPORTANT]
====
Make sure to regularly commit your changes to the repository.
This will allow you to experiment with an easy mind: if things go wrong, you can easily reset it to the last known working version.
====

include::getting-started/setting-up.asciidoc[]

include::getting-started/create-grid.asciidoc[]

include::getting-started/igame.asciidoc[]

include::getting-started/visualizing-squares.asciidoc[]

include::getting-started/view-models.asciidoc[]

include::getting-started/uncovering.asciidoc[]

include::getting-started/reactive.asciidoc[]

// include::getting-started/invalid-moves.asciidoc[]




// == Drawing Squares

// === Giving Color

// Right now, we draw each square using

// [source,xml]
// ----
// <Button Content="{Binding Square.Value}" Width="32" Height="32" />
// ----

// In other words, we tell the `Button` that its contents are equal to its `DataContext`, which itself is equal to a `string`. But we're setting this using the `ToString()` method to fill in the text from the ViewModel, and per requirements strings passed from Model or ViewModel are not allowed. So lets draw something starting from Square ourselves.

// [NOTE,caption={task-caption}]
// ====
// In `MainWindow.xaml`, change the button to

// [source,xml]
// ----
// <Button Width="32" Height="32" Command="{Binding UncoverSquare}">
//     <Grid Width="24" Height="24">
//         <Ellipse Fill="red"/>
//         <TextBlock HorizontalAlignment="Center" Text="0" TextAlignment="Center" VerticalAlignment="Center"/>
//     </Grid>
// </Button>
// ----

// Run the code.
// Every button should now contain a small red circle with a 0 in the middle.
// ====

// === SquareConverter

// Next step is to have the ``Ellipse``'s `Fill` and ``TextBlock``'s `Text` vary according to the state of a square, there are 4 possible states:

// [.center,cols="^,^,^",options="header",width="80%"]
// |===
// | Square State | Ellipse Fill Brush | Text
// | Covered | Transparent | None
// | Uncovered | Transparent | #AdjacentMines
// | Flagged (& covered) | Orange | None
// | Mine (& uncovered) | Black | None
// |===

// To convert from `Square` to `Brush` and `string`, we need to create an `IValueConverter`. But `IValueConverter` only accepts one input while we require atleast two arguments: the state of the square and the amount of adjacent mines. We also can not give Square itself as input since it doesn't have these properties. Instead we can use a `wrapper` class that exposes these 2 values as properties and pass an instance of that class to the converter.

// [source,csharp]
// ----
// public class SquareWrapper()
// {
//     public bool IsCovered { get; }
//     public bool IsMine { get; }
//     public bool IsFlagged { get; }

//     public int AdjacentMines { get; }

//     public SquareWrapper(IGame game, Vector2D position)
//     {
//         ...
//     }
// }
// ----

// [NOTE,caption={task-caption}]
// ====
// * Implement SquareWrapper in the ViewModel project using functions from IGame. Handle functions that throw errors properly without try-catch.
// * In SquareViewModel, change the type of property Square from `ICell<string>` to `ICell<SquareWrapper>`
// * Add a new folder named `Converters` to your View project.
// * Add a new class file named `SquareColorConverter.cs` to this folder.
// * Have `SquareColorConverter` implement `IValueConverter`, i.e., have Visual Studio generate stubs.
// * In the `Convert` method
// ** The first parameter `value` corresponds to the `wrapper`.
//    It has type `object`, but that's not a problem.
//    We can simply cast the object to the type `SquareWrapper`.
// ** If `wrapper.IsMine`, return `Brushes.Black`.
// ** If `wrapper.IsFlagged`, return `Brushes.Orange`.
// ** If `wrapper.IsCovered`, return `Brushes.Transparent`.
// ** If `!wrapper.IsCovered`, return `Brushes.Transparent`.
// ====

// We can now use this converter.

// [NOTE,caption={task-caption}]
// ====
// In `MainWindow.xaml`:

// * We want to access `SquareColorConverter`, which resides in the `View.Converters` namespace.
//   For this, we need to add an extra namespace mapping.
//   Add the following attribute to `Window` (the top element):
// +
// [source,diff]
// ----
//   <Window ...
//           xmlns:local="clr-namespace:View"
// +         xmlns:converters="clr-namespace:View.Converters"
//           ...>
// ----
// * Create the `SquareColorConverter` as a resource.
// +
// [source,diff]
// ----
//   <Window ...>
// +     <Window.Resources>
// +         <converters:SquareColorConverter x:Key="squareToBrushConverter" />
// +     </Window.Resources>
//       ...
//   </Window>
// ----
// * Bind `Fill` to the `DataContext` itself.
//   Have it https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/staticresource-markup-extension[use] `squareToBrushConverter` as converter.

// Run your code.
// If you did everything correctly, you will see 0's everywhere but if you hit a mine, the mines will appear as circles.
// ====

// === Generalizing SquareColorConverter

// Hardcoding the colors in `SquareColorConverter` is actually a bad idea:

// * We can easily generalize it so that it becomes reusable.
// * The color of the squares should be determined by an artist, not a programmer.
//   Specifying the color in C# code is not very artist-friendly: they'd rather define everything in XAML.
// * If we need more elaborate brushes, it's easier to define them in XAML than in C#.

// So let us improve our `SquareColorConverter`.

// [NOTE,caption={task-caption}]
// ====
// In `SquareColorConverter`:

// * Add four properties `Covered`, `Uncovered`, `Flagged` and `Mine`. Each has type `object` and has both a getter and setter.
// * In the `Convert` method, return the values of `Covered`, `Uncovered`, `Flagged` and `Mine` instead of hardcoded brushes.

// In `MainWindow.xaml`, initialize the four properties of the `SquareColorConverter`.
// [source,diff]
// ----
//   <Window ...>
//       <Window.Resources>
// -         <converters:SquareColorConverter x:Key="squareToBrushConverter" />
// +         <converters:SquareColorConverter x:Key="squareToBrushConverter"
// +                                    Covered="Transparent"
// +                                    Uncovered="Transparent"
// +                                    Flagged="Orange"
// +                                    Mine="Black" />
//       </Window.Resources>
//       ...
//   </Window>
// ----

// * Create a second converter `SquareTextConverter` to fill in the `Text` of `TextBlock` so that it only shows adjacent mines when uncovered.
// ====

// Run your code and check that everything works as intended.

// == Flagging Squares

// Now we got most of Minesweeper core functionalities working, we're still missing flags.
// In Minesweeper, it is the tradition to flag a square using the right mouse button, for that we'll need to add an InputBinding to the button.

// [source,xml]
// ----
// <Button Width="32" Height="32" Command="{Binding UncoverSquare}">
//     <Grid Width="24" Height="24">
//         <Button.InputBindings>
//             <MouseBinding Gesture="RightClick" Command="{Binding FlagSquare}" />
//         </Button.InputBindings>
//         ...
//     </Grid>
// </Button>
// ----


// [NOTE,caption={task-caption}]
// ====
// * Add the gesture RightClick to the button's InputBindings as above
// * Implement the FlagSquare command, the method `IGame.FlagSquare` acts as a toggle: use the same method to turn it `on` and `off`.
// ====

// Run your code and check that flags are working.

// The guide ends here but you are not at the project minimum requirements just yet.
// Head over to the <<requirements.asciidoc#,Requirements>> page to see what more you can do.