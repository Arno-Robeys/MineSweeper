// ROOT
:tip-caption: 💡
:note-caption: ℹ️
:important-caption: ⚠️
:task-caption: 🔨
:source-highlighter: pygments
:toc: left
:toclevels: 3
:experimental:
:nofooter:

= Getting Started

[IMPORTANT]
====
Make sure to regularly commit your changes to the repository.
This will allow you to experiment with an easy mind: if things go wrong, you can easily reset it to the last known working version.
====

include::getting-started/setting-up.asciidoc[]

include::getting-started/create-grid.asciidoc[]

include::getting-started/igame.asciidoc[]

include::getting-started/visualizing-squares.asciidoc[]

include::getting-started/view-models.asciidoc[]

include::getting-started/uncovering.asciidoc[]



// == Reactive Programming

// Now that `UncoverSquareCommand` has both the `IGame` object and its position, surely we're ready to make it work?
// Sadly, there's still one problem: ``IGame``'s `Uncover` does not modify the object, but returns a new one.
// We clearly need to do _something_ with this new `IGame` object, but what?

// The new `IGame` object contains an updated board.
// This means that all ``SquareViewModel``s should update their `Square` property.
// However, the `UncoverSquareCommand` object has no way of contacting each `SquareViewModel`.
// We could of course give each `UncoverSquareCommand` object a list of all existing ``SquareViewModel``s so that it can ask them to refresh themselves.
// Fortunately, there is a much easier solution.

// Note that not only do we need the ``SquareViewModel``s to update their `Square` property, we also need the View to be aware of this change.
// Without some kind of notification, the View will not know of this update and therefore not see any reason of updating itself.

// This is where Reactive Programming shows its strength.
// In short, Reactive Programming consists of having variables automatically update themselves whenever another variable changes.
// Consider this example:

// [source,csharp]
// ----
// var x = 1;
// var doubleOfX = x * 2;
// x = 5;
// ----

// After the execution of the last statement, `doubleOfX` will be equal to `2`, even though `x` equals `5`.
// Wouldn't it make more sense for `doubleOfX` to be `10`?

// The reason for this, of course, is that `doubleOfX` has been initialized at a time where `x` was still `1`.
// Changing `x` does not cause `doubleOfX` to be magically updated alongside with it.

// Reactive Programming involves creating variables that _do_ update themselves automatically.
// For example,

// [source,csharp]
// ----
// var x = 1;
// var doubleOfX = x * 2; // doubleOfX == 2
// x = 5;                 // doubleOfX == 10
// x = 2;                 // doubleOfX == 4
// x = 7;                 // doubleOfX == 14
// ----

// However, Reactive Programming is not built into C#.
// This is where Cells come in: these can be used to "fake" Reactive Programming.

// [source,csharp]
// ----
// var x = Cell.Create(1);
// var doubleOfX = x.Derive(k => k * 2); // doubleOfX.Value == 2
// x.Value = 5;                          // doubleOfX.Value == 10
// x.Value = 2;                          // doubleOfX.Value == 4
// x.Value = 7;                          // doubleOfX.Value == 14
// ----

// Here, `Derive` creates a new element that is kept in sync with the original element.
// The lambda `k => k * 2` expresses how `doubleOfX` is related to `x`:

// * The parameter `k` contains the value of the original element (`x`).
// * The body `k * 2` tells how to compute the derived element's value (`doubleOfX`).

// Let's see how we can leverage Reactive Programming in the case of Minesweeper.

// === Cell

// Say we start off with an `ICell<IGame>` in which we store the current game state.

// [source,csharp]
// ----
// var currentGame = Cell.Create(IGame.Create(5, true));
// ----

// From this we can derive the game board:

// [source,csharp]
// ----
// var currentGameBoard = currentGame.Derive(g => g.Board);
// ----

// We can then create a derived element that contains the square in the upper left corner of the board:

// [source,csharp]
// ----
// var upperLeftCorner = currentGameBoard.Derive(b => b[new Vector2D(0,0)]);
// ----

// Initially, `upperLeftCorner.Value` will be covered, since that square hasn't been visited yet.
// Say we visit there:

// [source,csharp]
// ----
// // Uncovering a square
// currentGame.Value = currentGame.Value.UncoverSquare( new Vector2D(0, 0) );
// ----

// It is important that you understand what is going on here:

// * We retrieve the current game from the cell: `currentGame.Value` in the right side of the assignment.
// * We call `Uncover` on this `IGame` object.
// * This returns a new `IGame` object.
// * We store this new `IGame` object in the `currentGame` cell.
// * The change in `currentGame` causes `currentGameBoard` to be updated.
// * `upperLeftCorner` is aware of this change and fetches its new value from the board: `Uncovered or Mine`.

// We can create one derived cell per square and wrap each one in a `SquareViewModel` object.

// image::game-cell.svg[Static,600,align="center"]

// Using cells takes care of two issues at once:

// * We don't need to manually update all ``SquareViewModel``s `Square` property anymore: this is done automatically by derived cells.
// * WPF "understands" cells (because they implement the `INotifyPropertyChanged` interface). Whenever a cell's value changes, WPF will know that it will need to rerender the view.

// It is now time for you to introduce cells in your code.

// [NOTE,caption={task-caption}]
// ====
// * `GameViewModel`
// ** Its constructor receives an `IGame` and stores it in a field with type `IGame`.
// ** Change the field type to `ICell<IGame>` and update the constructor correspondingly.
//    Note that the parameter type should remain simply `IGame`.
// * `GameBoardViewModel`
// ** In `GameBoardViewModel`, update the `board` field's type from `IGameBoard` to `ICell<IGameBoard>`.
// ** Its constructor should now accept an `ICell<IGame>` instead of an `IGame`.
// ** From this cell, derive an `ICell<IGameBoard>` and store it in the field.
// * `GameBoardRowViewModel`
// ** Its constructor should now receive an `ICell<IGame>`.
// * `SquareViewModel`
// ** The constructor receives an `ICell<IGame>`.
// ** Change the `Square` property's type to `ICell<string>` by using the ToString() method while deriving.
// ** In the constructor, initialize it to a derived cell that contains the `Square` at the appropriate position.
// * `UncoverSquareCommand`
// ** Its constructor should also receive the `ICell<IGame>` and store it in a field.
// * XAML code
// ** Update the `Content` binding. Since we upgraded property `Square` from type `Square` to `ICell<string>`, the binding needs to change from `Square` to `Square.Value`.

// Run your code and check that everything still works the same.
// ====

// === Making it Work

// We are finally ready to uncover squares on the board.

// [NOTE,caption={task-caption}]
// ====
// In ``UncoverSquareCommand``'s `Execute` method, call the ``IGame``'s `Uncover` and store its result back into the cell.

// Run the code.
// You should be able to uncover squares.
// ====

// == Invalid Moves

// If you click on a cell which has been uncovered already, the program will crash.
// This is due to `Uncover` throwing an exception when you're making an invalid move.

// === CellCommand

// Commands exist specifically to make it possible to disable them: if `CanExecute` is `false`, the button will block all clicks, which is exactly what we need.
// We would also need to signal `CanExecuteChanged` when ``CanExecute``'s result changes.

// This is more or less what cells do: they have values and broadcast a signal when this value changes.
// It'd be nice to also rely on cells when dealing with commands.
// Let's implement a command class that does exactly that.

// [NOTE,caption={task-caption}]
// ====
// * In the ViewModel, create a new class named `CellCommand`.
// * Have it implement `ICommand`, i.e., have Visual Studio generate stubs.
// * The constructor should receive a parameter `ICell<bool> canExecute`.
// * This `canExecute` cell should be stored in a field.
// * Have `CanExecute` return the contents of the cell.
// * When the cell changes value, `CanExecuteChanged` needs to be called. In the `CellCommand` constructor, add
// +
// [source,csharp]
// ----
// this.canExecute.ValueChanged += () => CanExecuteChanged?.Invoke(this, new EventArgs());
// ----
// ** `() => CanExecuteChanged?.Invoke(this, new EventArgs())` is an anonymous function that takes no parameters (represented by `()` before the arrow) and has as body `CanExecuteChanged?.Invoke(this, new EventArgs())`.
// ** The `?.` operator first checks if `CanExecuteChanged` is `null`. If so, the call to `Invoke` is not made since it would lead to a `NullReferenceException`.
// ====

// All that remains to be implemented is the `Execute` method.
// We could leave it abstract and expect users to subclass our `CellCommand`.
// A more user-friendly solution would be to let the user pass along the code for `Execute` as a constructor parameter.

// [NOTE,caption={task-caption}]
// ====
// * Add an extra parameter `Action execute` to ``CellCommand``'s constructor.
// * Store it in a field.
// * Call it in the `Execute` method.
// ====

// === Revisiting UncoverSquareCommand

// Let's rewrite `UncoverSquareCommand` so as to make use of this `CellCommand`, still ignoring move validity for now.

// [NOTE,caption={task-caption}]
// ====
// In ``SquareViewModel``'s constructor

// * Add a local variable `ICell<bool> isValidMove` that is simply initialized to `true`.
//   We will have to fix this in a later step.
// * Initialize `PutStone` with a `CellCommand`.
//   The `execute` parameter should be set to a lambda that contains the same code as ``UncoverSquareCommand``'s `Execute` method.
// * Remove `UncoverSquareCommand` altogether.

// Run your code.
// Everything should still work as before, i.e., it should still be possible crash the game by putting a stone in an already occupied crash.
// ====

// We now introduce the move validity check.

// [NOTE,caption={task-caption}]
// ====
// In ``SquareViewModel``'s constructor

// * Set `isValidMove` to a cell of type `ICell<bool>` that derives from `game`.
//   Its contents should reflect whether it is valid to uncover at the square's position.
//   Look in `IGame` for methods that could prove useful.

// Run your code.
// The application should not crash anymore when attempting to uncover a square that has already been uncovered.
// ====

// == Drawing Squares

// === Giving Color

// Right now, we draw each square using

// [source,xml]
// ----
// <Button Content="{Binding Square.Value}" Width="32" Height="32" />
// ----

// In other words, we tell the `Button` that its contents are equal to its `DataContext`, which itself is equal to a `string`. But we're setting this using the `ToString()` method to fill in the text from the ViewModel, and per requirements strings passed from Model or ViewModel are not allowed. So lets draw something starting from Square ourselves.

// [NOTE,caption={task-caption}]
// ====
// In `MainWindow.xaml`, change the button to

// [source,xml]
// ----
// <Button Width="32" Height="32" Command="{Binding UncoverSquare}">
//     <Grid Width="24" Height="24">
//         <Ellipse Fill="red"/>
//         <TextBlock HorizontalAlignment="Center" Text="0" TextAlignment="Center" VerticalAlignment="Center"/>
//     </Grid>
// </Button>
// ----

// Run the code.
// Every button should now contain a small red circle with a 0 in the middle.
// ====

// === SquareConverter

// Next step is to have the ``Ellipse``'s `Fill` and ``TextBlock``'s `Text` vary according to the state of a square, there are 4 possible states:

// [.center,cols="^,^,^",options="header",width="80%"]
// |===
// | Square State | Ellipse Fill Brush | Text
// | Covered | Transparent | None
// | Uncovered | Transparent | #AdjacentMines
// | Flagged (& covered) | Orange | None
// | Mine (& uncovered) | Black | None
// |===

// To convert from `Square` to `Brush` and `string`, we need to create an `IValueConverter`. But `IValueConverter` only accepts one input while we require atleast two arguments: the state of the square and the amount of adjacent mines. We also can not give Square itself as input since it doesn't have these properties. Instead we can use a `wrapper` class that exposes these 2 values as properties and pass an instance of that class to the converter.

// [source,csharp]
// ----
// public class SquareWrapper()
// {
//     public bool IsCovered { get; }
//     public bool IsMine { get; }
//     public bool IsFlagged { get; }

//     public int AdjacentMines { get; }

//     public SquareWrapper(IGame game, Vector2D position)
//     {
//         ...
//     }
// }
// ----

// [NOTE,caption={task-caption}]
// ====
// * Implement SquareWrapper in the ViewModel project using functions from IGame. Handle functions that throw errors properly without try-catch.
// * In SquareViewModel, change the type of property Square from `ICell<string>` to `ICell<SquareWrapper>`
// * Add a new folder named `Converters` to your View project.
// * Add a new class file named `SquareColorConverter.cs` to this folder.
// * Have `SquareColorConverter` implement `IValueConverter`, i.e., have Visual Studio generate stubs.
// * In the `Convert` method
// ** The first parameter `value` corresponds to the `wrapper`.
//    It has type `object`, but that's not a problem.
//    We can simply cast the object to the type `SquareWrapper`.
// ** If `wrapper.IsMine`, return `Brushes.Black`.
// ** If `wrapper.IsFlagged`, return `Brushes.Orange`.
// ** If `wrapper.IsCovered`, return `Brushes.Transparent`.
// ** If `!wrapper.IsCovered`, return `Brushes.Transparent`.
// ====

// We can now use this converter.

// [NOTE,caption={task-caption}]
// ====
// In `MainWindow.xaml`:

// * We want to access `SquareColorConverter`, which resides in the `View.Converters` namespace.
//   For this, we need to add an extra namespace mapping.
//   Add the following attribute to `Window` (the top element):
// +
// [source,diff]
// ----
//   <Window ...
//           xmlns:local="clr-namespace:View"
// +         xmlns:converters="clr-namespace:View.Converters"
//           ...>
// ----
// * Create the `SquareColorConverter` as a resource.
// +
// [source,diff]
// ----
//   <Window ...>
// +     <Window.Resources>
// +         <converters:SquareColorConverter x:Key="squareToBrushConverter" />
// +     </Window.Resources>
//       ...
//   </Window>
// ----
// * Bind `Fill` to the `DataContext` itself.
//   Have it https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/staticresource-markup-extension[use] `squareToBrushConverter` as converter.

// Run your code.
// If you did everything correctly, you will see 0's everywhere but if you hit a mine, the mines will appear as circles.
// ====

// === Generalizing SquareColorConverter

// Hardcoding the colors in `SquareColorConverter` is actually a bad idea:

// * We can easily generalize it so that it becomes reusable.
// * The color of the squares should be determined by an artist, not a programmer.
//   Specifying the color in C# code is not very artist-friendly: they'd rather define everything in XAML.
// * If we need more elaborate brushes, it's easier to define them in XAML than in C#.

// So let us improve our `SquareColorConverter`.

// [NOTE,caption={task-caption}]
// ====
// In `SquareColorConverter`:

// * Add four properties `Covered`, `Uncovered`, `Flagged` and `Mine`. Each has type `object` and has both a getter and setter.
// * In the `Convert` method, return the values of `Covered`, `Uncovered`, `Flagged` and `Mine` instead of hardcoded brushes.

// In `MainWindow.xaml`, initialize the four properties of the `SquareColorConverter`.
// [source,diff]
// ----
//   <Window ...>
//       <Window.Resources>
// -         <converters:SquareColorConverter x:Key="squareToBrushConverter" />
// +         <converters:SquareColorConverter x:Key="squareToBrushConverter"
// +                                    Covered="Transparent"
// +                                    Uncovered="Transparent"
// +                                    Flagged="Orange"
// +                                    Mine="Black" />
//       </Window.Resources>
//       ...
//   </Window>
// ----

// * Create a second converter `SquareTextConverter` to fill in the `Text` of `TextBlock` so that it only shows adjacent mines when uncovered.
// ====

// Run your code and check that everything works as intended.

// == Flagging Squares

// Now we got most of Minesweeper core functionalities working, we're still missing flags.
// In Minesweeper, it is the tradition to flag a square using the right mouse button, for that we'll need to add an InputBinding to the button.

// [source,xml]
// ----
// <Button Width="32" Height="32" Command="{Binding UncoverSquare}">
//     <Grid Width="24" Height="24">
//         <Button.InputBindings>
//             <MouseBinding Gesture="RightClick" Command="{Binding FlagSquare}" />
//         </Button.InputBindings>
//         ...
//     </Grid>
// </Button>
// ----


// [NOTE,caption={task-caption}]
// ====
// * Add the gesture RightClick to the button's InputBindings as above
// * Implement the FlagSquare command, the method `IGame.FlagSquare` acts as a toggle: use the same method to turn it `on` and `off`.
// ====

// Run your code and check that flags are working.

// The guide ends here but you are not at the project minimum requirements just yet.
// Head over to the <<requirements.asciidoc#,Requirements>> page to see what more you can do.