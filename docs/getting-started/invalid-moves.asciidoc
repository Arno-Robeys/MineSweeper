== Invalid Moves

If you click on a cell which has been uncovered already, the program will crash.
This is due to `Uncover` throwing an exception when you're making an invalid move.

=== CellCommand

Commands exist specifically to make it possible to disable them: if `CanExecute` is `false`, the button will block all clicks, which is exactly what we need.
We would also need to signal `CanExecuteChanged` when ``CanExecute``'s result changes.

This is more or less what cells do: they have values and broadcast a signal when this value changes.
It'd be nice to also rely on cells when dealing with commands.
Let's implement a command class that does exactly that.

[NOTE,caption={task-caption}]
====
* In the ViewModel, create a new class named `CellCommand`.
* Have it implement `ICommand`, i.e., have Visual Studio generate stubs.
* The constructor should receive a parameter `ICell<bool> canExecute`.
* This `canExecute` cell should be stored in a field.
* Have `CanExecute` return the contents of the cell.
* When the cell changes value, `CanExecuteChanged` needs to be called. In the `CellCommand` constructor, add
+
[source,csharp]
----
this.canExecute.ValueChanged += () => CanExecuteChanged?.Invoke(this, new EventArgs());
----
** `() => CanExecuteChanged?.Invoke(this, new EventArgs())` is an anonymous function that takes no parameters (represented by `()` before the arrow) and has as body `CanExecuteChanged?.Invoke(this, new EventArgs())`.
** The `?.` operator first checks if `CanExecuteChanged` is `null`. If so, the call to `Invoke` is not made since it would lead to a `NullReferenceException`.
====

All that remains to be implemented is the `Execute` method.
We could leave it abstract and expect users to subclass our `CellCommand`.
A more user-friendly solution would be to let the user pass along the code for `Execute` as a constructor parameter.

[NOTE,caption={task-caption}]
====
* Add an extra parameter `Action execute` to ``CellCommand``'s constructor.
* Store it in a field.
* Call it in the `Execute` method.
====

=== Revisiting UncoverSquareCommand

Let's rewrite `UncoverSquareCommand` so as to make use of this `CellCommand`, still ignoring move validity for now.

[NOTE,caption={task-caption}]
====
In ``SquareViewModel``'s constructor

* Add a local variable `ICell<bool> isValidMove` that is simply initialized to `true`.
  We will have to fix this in a later step.
* Initialize `PutStone` with a `CellCommand`.
  The `execute` parameter should be set to a lambda that contains the same code as ``UncoverSquareCommand``'s `Execute` method.
* Remove `UncoverSquareCommand` altogether.

Run your code.
Everything should still work as before, i.e., it should still be possible crash the game by putting a stone in an already occupied crash.
====

We now introduce the move validity check.

[NOTE,caption={task-caption}]
====
In ``SquareViewModel``'s constructor

* Set `isValidMove` to a cell of type `ICell<bool>` that derives from `game`.
  Its contents should reflect whether it is valid to uncover at the square's position.
  Look in `IGame` for methods that could prove useful.

Run your code.
The application should not crash anymore when attempting to uncover a square that has already been uncovered.
====
