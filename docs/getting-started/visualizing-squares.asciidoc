== Visualizing Squares

We turn our attention on visualizing each ``Square``'s state.

[IMPORTANT]
====
In the final version of your project, you must not rely on `ToString()` methods.
Use it for debugging only.
This is a general rule applicable to all projects written in any OO-language.
====

We will want to be able to test each visualization, so let's hardcode a game board so that all possible states are visible.

[NOTE,caption={task-caption}]
====
In the `MainWindow` constructor, rely on `IGame.UncoverSquare` and `IGame.ToggleFlag` to

* Have at least one covered square.
* Have at least one uncovered square without mine.
* Have at least one flagged square.
* Have an uncovered square with a mine.

[IMPORTANT]
=====
Note that the `IGame` object is stateless, meaning you cannot modify it.
`UncoverSquare` returns a *new* `IGame` object instead of modifying it.
=====

Run your code to check that the buttons contain the expected labels.
====

Our goal is to implement the following `Square` visualization:

* A covered square remains blank.
* A flagged square shows an orange circle.
* An uncovered mine-free square shows the number.
* An uncovered mined square shows a black circle.

=== Querying Squares

First, let's find out how to access the information necessary for us to render a square onto the screen.
A `Button` gets a `Square` object as `DataContext`.
Go take a look at the implementation of the `Square` class.
Two members are interesting for our current purposes:

* The `Status` property.
* The `NeighboringMineCount` property.

With this data, we can render out squares.

=== Circle

Always start simple: we start with drawing circle, regardless of the status of the `Square`.

[NOTE,caption={task-caption}]
====
Set the ``Button``'s `Content` to an `Ellipse`.
You will have to use https://docs.microsoft.com/en-us/windows/uwp/xaml-platform/xaml-syntax-guide#setting-a-property-by-using-property-element-syntax[property element syntax] for this.

Give the `Ellipse` a `Width` and `Height` of `20`.
Set its `Fill` to `Black`.

Run your code.
Every `Button` should contain a small circle.
====

=== Adaptive Color

We want to color of the `Ellipse` to change depending on the ``Square``'s status.
Translating domain information to visual information is often done using converters.

[NOTE,caption={task-caption}]
====
Under the View project, create a new folder named `Converters`.
Create a new file named `SquareStatusConverter.cs`.

Add a class that implements the interface `IValueConverter`.
Add the necessary methods, but you can leave them unimplemented for now.

[IMPORTANT]
=====
Notice the namespace in which the class resides: it should be `View.Converters`.
=====
====

We want the ``Ellipse``'s `Fill` property to be dependent on the ``Square``'s `Status` property:

[#convert-table]
[.center,cols="^,^",width="50%",options="header"]
|===
| Status      | Fill
| `Flagged`   | `Orange`
| `Covered`   | `Transparent`
| `Mine`      | `Black`
| `Uncovered` | `Transparent`
|===

[NOTE,caption={task-caption}]
====
Inside `MainWindow.xaml`, create a `SquareStatusConverter` and update ``Ellipse.Fill`` so that it changes with the ``Square``'s `State`.

* We need to refer to `SquareStatusConverter` in the XAML file.
  For this we will first need to "import" it.
  Add a https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml?view=netframeworkdesktop-4.8[namespace declaration] to import `View.Converters` as `converters`.
  There should already be a namespace declaration that maps `local` to the namespace `View`; use it as guide.
* Create a `SquareStatusConverter` as one of ``MainWindow``'s https://docs.microsoft.com/en-us/dotnet/desktop/wpf/systems/xaml-resources-overview?view=netdesktop-6.0[resources].
  Name it `squareStatusToEllipseFill` (using the `x:Key` property).
* Set the ``Ellipse``'s `Fill` property to a `Binding` on `Status`.
  Have it use `squareStatusToEllipseFill` as a converter.

Feel free to https://docs.microsoft.com/en-us/dotnet/desktop/wpf/data/how-to-convert-bound-data?view=netframeworkdesktop-4.8[consult the documentation] in case you run into trouble.
====

Before implementing actual logic, we want to test this code.
We add the minimal amount of code to make it run.

[NOTE,caption={task-caption}]
====
Have `SquareStatusConverter.Convert` simply return `Brushes.Red`.
Run your code.
All circles should now be colored red.
====

Once this works, we can give `SquareStatusConverter` a real implementation.

[NOTE,caption={task-caption}]
====
Implement the `SquareStatusConverter.Convert` method.
Given a `SquareStatus` (through its first parameter) it should convert it to a `Brush` (which is what `Eclipse.Fill` expects).

* Its first parameter `value` should be cast to `SquareStatus`.
* Return the <<#convert-table,correct color>> based on the `SquareStatus`.
  This https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.brushes?view=windowsdesktop-6.0[class] might prove helpful.

Check your work by running your application.
====
